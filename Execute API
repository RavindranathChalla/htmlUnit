

package com.citi.cpt.apim.onboarding.services;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import javax.servlet.http.HttpServletResponse;
import org.apache.commons.lang3.*;
import org.apache.commons.collections.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Service;

import com.google.gson.JsonObject;
import okhttp3.HttpUrl;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;


public class ExecuteApiCall {
	
	
	@Autowired
	Environment env;
	/*===================================START: By pass SSL================================================
	 * ===================================================================================================*/
    /********************************************************************************
     * Bypassing trust all certificates.
     *******************************************************************************/
    private static final TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {
        @Override
        public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType)
                throws CertificateException {
        }

        @Override
        public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType)
                throws CertificateException {
        }

        @Override
        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
            return new java.security.cert.X509Certificate[]{};
        }
    }};

	   private static final SSLContext trustAllSslContext;

	    static {
	        try {
	            trustAllSslContext = SSLContext.getInstance("SSL");
	            trustAllSslContext.init(null, trustAllCerts, new java.security.SecureRandom());
	        } catch (NoSuchAlgorithmException | KeyManagementException e) {
	            throw new RuntimeException(e);
	        }
	    }

	    private static final SSLSocketFactory trustAllSslSocketFactory = trustAllSslContext.getSocketFactory();

	    /********************************************************************************
	     * Ideally below should not be used in production unless we really don't
	     * care about the security.
	     *******************************************************************************/
	    public static OkHttpClient trustAllSslClient(OkHttpClient client) {
	        LOGGER.info("Using the trustAllSslClient is highly discouraged and should not be used in Production!");
	        okhttp3.OkHttpClient.Builder builder = client.newBuilder();
	        builder.sslSocketFactory(trustAllSslSocketFactory, (X509TrustManager) trustAllCerts[0]);
	        builder.hostnameVerifier(new HostnameVerifier() {
	            @Override
	            public boolean verify(String arg0, SSLSession arg1) {
	                return true;
	            }
	        });
	        return builder.build();
	    }
	
	private static final Logger LOGGER = LoggerFactory.getLogger(ExecuteApiCall.class);
	
	
	 public String postJsonReq(JsonObject incomingJsonObj, String endpoint, Map<String, String> headersMap, boolean isProxy) throws Exception {
	    	return postJsonReq(incomingJsonObj, endpoint, headersMap, null, isProxy);
	    }
	 
	    public String postJsonReq(JsonObject incomingJsonObj, String endpoint, Map<String, String> headersMap, Map<String, String> paramsMap, boolean isProxy) throws Exception {
	        LOGGER.info("[postJsonReq] Endpoint: " + endpoint + ", input: " + incomingJsonObj.toString() + ", headersMap: " + headersMap + ", paramsMap: " + paramsMap + ", isProxy: " + isProxy);
	        String output = null;

	        MediaType mediaType = MediaType.parse("application/json;odata=verbose");
	        RequestBody body = RequestBody.create(mediaType, incomingJsonObj.toString());
	        HttpUrl.Builder httpBuilder = HttpUrl.parse(endpoint).newBuilder();

	        //Iterate over map and add params if available
	        if (MapUtils.isNotEmpty(paramsMap)) {
	            Set<String> set = paramsMap.keySet();
	            for (String s : set) {
	                httpBuilder.addQueryParameter(s, paramsMap.get(s));
	            }
	        }
	        Request.Builder b = new Request.Builder();
	        if (MapUtils.isNotEmpty(headersMap)) {
	            Set<String> set = headersMap.keySet();
	            for (String s : set) {
	                b.addHeader(s, headersMap.get(s));
	                System.out.println("HEDER ADDED"+s+"-->"+headersMap.get(s));
	            }
	            
	        }
	        Request req = b.url(httpBuilder.build()).post(body).build();
	        output = getResponse(req, endpoint, isProxy);
	        LOGGER.info("RESPONSE FORM END POINT IS:- "+output);
	        return output;
	    }
	    
	    private String getResponse(Request req, String endpoint, boolean isProxy) throws IOException {
	    	return getResponse(req, endpoint, isProxy, null);
	    }
	    
	    private String getResponse(Request req, String endpoint, boolean isProxy, HttpServletResponse servletResponse) throws IOException {
	    	
	        OkHttpClient.Builder builder = null;
	        if(isProxy) {
	            LOGGER.trace("Adding proxy.");
	            Proxy proxyObj = new Proxy(Proxy.Type.HTTP, new InetSocketAddress("webproxy.wlb2.nam.nsroot.net", 8080));
	            builder = new OkHttpClient.Builder().proxy(proxyObj);
	        } else {
	            LOGGER.trace("Not adding proxy.");
	            builder = new OkHttpClient.Builder();
	        }

	        String timeoutStr = "120";
	        //String timeoutStr = StringUtils.defaultIfEmpty(env.getProperty("application.timeout"), "120");
	        int timeout = Integer.parseInt(timeoutStr);
	        builder.connectTimeout(timeout, TimeUnit.SECONDS);
	        builder.readTimeout(timeout, TimeUnit.SECONDS);
	        builder.writeTimeout(timeout, TimeUnit.SECONDS);
	        OkHttpClient client = trustAllSslClient(builder.build());
	       // OkHttpClient client = builder.build();
	        Response resObject = client.newCall(req).execute();
	        
	        
			byte[] contentBytes = resObject.body().bytes();
			String response = null;
			response = new String(contentBytes, "UTF-8");

			LOGGER.info("FULL response FROM endpoint: " +response);
			LOGGER.info("Readable response FROM endpoint: " +StringUtils.left(response, 2000)); //Print only first 2000 characters StringUtils.left(response, 2000)
			LOGGER.info("Readable response converted : " + resObject.toString()); //Print only first 2000
			return response;
	    }
	    
	   
	    public String putJsonReq(JsonObject incomingJsonObj, String endpoint, Map<String, String> headersMap, Map<String, String> paramsMap, boolean isProxy) throws Exception {
	        LOGGER.info("[postJsonReq] Endpoint: " + endpoint + ", input: " + incomingJsonObj.toString() + ", headersMap: " + headersMap + ", paramsMap: " + paramsMap + ", isProxy: " + isProxy);
	        String output = null;
	        MediaType mediaType = MediaType.parse("application/json;odata=verbose");
	        RequestBody body = RequestBody.create(mediaType, incomingJsonObj.toString());
	        HttpUrl.Builder httpBuilder = HttpUrl.parse(endpoint).newBuilder();

	        //Iterate over map and add params if available
	        if (MapUtils.isNotEmpty(paramsMap)) {
	            Set<String> set = paramsMap.keySet();
	            for (String s : set) {
	                httpBuilder.addQueryParameter(s, paramsMap.get(s));
	            }
	        }
	        Request.Builder b = new Request.Builder();
	        if (MapUtils.isNotEmpty(headersMap)) {
	            Set<String> set = headersMap.keySet();
	            for (String s : set) {
	                b.addHeader(s, headersMap.get(s));
	                System.out.println("HEDER ADDED"+s+"-->"+headersMap.get(s));
	            }
	            
	        }
	        Request req = b.url(httpBuilder.build()).put(body).build();
	        output = getResponse(req, endpoint, isProxy);
	        LOGGER.info("RESPONSE FORM END POINT IS:- "+output);
	        return output;
	    }
	    
	    public Response getHttpResponseObject( String endpoint, Map<String, String> headersMap,
				Map<String, String> paramsMap, boolean isProxy) throws Exception {
			LOGGER.info("[getJsonReq] Endpoint: " + endpoint + ", headersMap: "
					+ headersMap + ", paramsMap: " + paramsMap + ", isProxy: " + isProxy);
			String output = null;

			MediaType mediaType = MediaType.parse("application/json;odata=verbose");
			//RequestBody body = RequestBody.create(mediaType, incomingJsonObj.toString());
			HttpUrl.Builder httpBuilder = HttpUrl.parse(endpoint).newBuilder();

			// Iterate over map and add params if available
			if (MapUtils.isNotEmpty(paramsMap)) {
				Set<String> set = paramsMap.keySet();
				for (String s : set) {
					httpBuilder.addQueryParameter(s, paramsMap.get(s));
				}
			}
			Request.Builder b = new Request.Builder();
			if (MapUtils.isNotEmpty(headersMap)) {
				Set<String> set = headersMap.keySet();
				for (String s : set) {
					b.addHeader(s, headersMap.get(s));
				}

			}
			Request req = b.url(httpBuilder.build()).get().build();
			Response responseObject = getResponseObject(req, endpoint, isProxy);
			LOGGER.info("getHttpResponseObject: responseObject from endpoint:- " + responseObject);
			return responseObject;
		}
		
		private Response getResponseObject(Request req, String endpoint, boolean isProxy) throws IOException {
			
			OkHttpClient.Builder builder = null;
			if (isProxy) {
				LOGGER.trace("Adding proxy.");
				Proxy proxyObj = new Proxy(Proxy.Type.HTTP, new InetSocketAddress("webproxy.wlb2.nam.nsroot.net", 8080));
				builder = new OkHttpClient.Builder().proxy(proxyObj);
			} else {
				LOGGER.trace("Not adding proxy.");
				builder = new OkHttpClient.Builder();
			}

			String timeoutStr = "120";
			int timeout = Integer.parseInt(timeoutStr);
			builder.connectTimeout(timeout, TimeUnit.SECONDS);
			builder.readTimeout(timeout, TimeUnit.SECONDS);
			builder.writeTimeout(timeout, TimeUnit.SECONDS);
			 OkHttpClient client = trustAllSslClient(builder.build());
			//OkHttpClient client = builder.build();
			Response resObject = client.newCall(req).execute();
			return resObject;
		}
		
		
		/**
		 * This method will do GET call for any EndPoint URL and 
		 * returns Response Object.
		 *
		 * @param headersMap providerOrgName
		 * @param paramsMap  clientId
		 * @param endpoint
		 * @param isproxy
		 * @return Response Object  
		 *  
		 */
		 public Response getJsonResponse(String endpoint, Map<String, String> headersMap, Map<String, String> paramsMap, boolean isProxy) throws Exception {
		    
		        MediaType mediaType = MediaType.parse("application/json;odata=verbose");
		        HttpUrl.Builder httpBuilder = HttpUrl.parse(endpoint).newBuilder();

		        //Iterate over map and add params if available
		        if (MapUtils.isNotEmpty(paramsMap)) {
		            Set<String> set = paramsMap.keySet();
		            for (String s : set) {
		                httpBuilder.addQueryParameter(s, paramsMap.get(s));
		            }
		        }
		        Request.Builder b = new Request.Builder();
		        if (MapUtils.isNotEmpty(headersMap)) {
		            Set<String> set = headersMap.keySet();
		            for (String s : set) {
		                b.addHeader(s, headersMap.get(s));
		                LOGGER.info("HEADER ADDED"+s+"-->"+headersMap.get(s));
		            }
		            
		        }
		        Request req = b.url(httpBuilder.build()).get().build();
				Response responseObject = getResponseObject(req, endpoint, isProxy);
		        LOGGER.info("RESPONSE FORM END POINT IS:- "+ responseObject.toString());
		        return responseObject;
		    }
		 
		 /*
		     * 
		     *  ####################################################
		     */
		    
		    public Response postJsonForResponse(JsonObject incomingJsonObj, String endPoint, Map<String, String> headersMap,
					Map<String, String> paramsMap, boolean isProxy) throws Exception {
				LOGGER.info("[postJsonReq] Endpoint: " + endPoint + ", input: " + incomingJsonObj.toString() + ", headersMap: "
						+ headersMap + ", paramsMap: " + paramsMap + ", isProxy: " + isProxy);
	/*
				MediaType mediaType = MediaType.parse("application/json;odata=verbose");
				RequestBody body = RequestBody.create(mediaType, incomingJsonObj.toString());
				HttpUrl.Builder httpBuilder = HttpUrl.parse(endpoint).newBuilder();

				// Iterate over map and add params if available
				if (MapUtils.isNotEmpty(paramsMap)) {
					Set<String> set = paramsMap.keySet();
					for (String s : set) {
						httpBuilder.addQueryParameter(s, paramsMap.get(s));
					}
				}
				Request.Builder b = new Request.Builder();
				if (MapUtils.isNotEmpty(headersMap)) {
					Set<String> set = headersMap.keySet();
					for (String s : set) {
						b.addHeader(s, headersMap.get(s));
					}

				}
				Request req = b.url(httpBuilder.build()).post(body).build();*/
				Request req=buildRequest(incomingJsonObj, endPoint, headersMap, paramsMap);
				OkHttpClient client=buildHttpClient(isProxy);
				Response resObject = client.newCall(req).execute();

				/*byte[] contentBytes = resObject.body().bytes();
				String response = null;
				response = new String(contentBytes, "UTF-8");

				LOGGER.info("FULL response FROM endpoint: " + response);
				LOGGER.info("Readable response converted to Response Object " + resObject.toString()); */
				return resObject;
				
			}
		    
		    private OkHttpClient buildHttpClient(boolean isProxy){
		    	
		    	OkHttpClient.Builder builder = null;
				if (isProxy) {
					LOGGER.trace("Adding proxy.");
					String proxyHost = env.getProperty("application.proxyHost");
					String proxyHostPort = env.getProperty("application.proxyHostPort");
					Integer port = Integer.parseInt(proxyHostPort);
					Proxy proxyObj = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, port));
					builder = new OkHttpClient.Builder().proxy(proxyObj);
				} else {
					LOGGER.trace("Not adding proxy.");
					builder = new OkHttpClient.Builder();
				}

				String timeoutStr ="120";
				int timeout = Integer.parseInt(timeoutStr);
				builder.connectTimeout(timeout, TimeUnit.SECONDS);
				builder.readTimeout(timeout, TimeUnit.SECONDS);
				builder.writeTimeout(timeout, TimeUnit.SECONDS);
				OkHttpClient client = trustAllSslClient(builder.build());
				//OkHttpClient client = builder.build();
				return client;
		    }

			
			private Request buildRequest(JsonObject incomingJsonObj,String endPoint,Map<String, String> headersMap,
										Map<String, String> paramsMap){
				MediaType mediaType = MediaType.parse("application/json;odata=verbose");
				RequestBody body = RequestBody.create(mediaType, incomingJsonObj.toString());
				HttpUrl.Builder httpBuilder = HttpUrl.parse(endPoint).newBuilder();

				// Iterate over map and add params if available
				if (MapUtils.isNotEmpty(paramsMap)) {
					Set<String> set = paramsMap.keySet();
					for (String s : set) {
						httpBuilder.addQueryParameter(s, paramsMap.get(s));
					}
				}
				Request.Builder b = new Request.Builder();
				if (MapUtils.isNotEmpty(headersMap)) {
					Set<String> set = headersMap.keySet();
					for (String s : set) {
						b.addHeader(s, headersMap.get(s));
					}
	;
				}
				Request req = b.url(httpBuilder.build()).post(body).build();
				return req;
			}
			
			public Response putJsonForResponse(JsonObject incomingJsonObj, String endPoint, Map<String, String> headersMap,
					Map<String, String> paramsMap, boolean isProxy) throws Exception {
				LOGGER.info("[postJsonReq] Endpoint: " + endPoint + ", input: " + incomingJsonObj.toString() + ", headersMap: "
						+ headersMap + ", paramsMap: " + paramsMap + ", isProxy: " + isProxy);

				Request req=buildPutRequest(incomingJsonObj, endPoint, headersMap, paramsMap);
				OkHttpClient client=buildHttpClient(isProxy);
				Response resObject = client.newCall(req).execute();

				return resObject;
				
			}
			
			 
			private Request buildPutRequest(JsonObject incomingJsonObj,String endPoint,Map<String, String> headersMap,
											Map<String, String> paramsMap){
					MediaType mediaType = MediaType.parse("application/json;odata=verbose");
					RequestBody body = RequestBody.create(mediaType, incomingJsonObj.toString());
					HttpUrl.Builder httpBuilder = HttpUrl.parse(endPoint).newBuilder();

					// Iterate over map and add params if available
					if (MapUtils.isNotEmpty(paramsMap)) {
						Set<String> set = paramsMap.keySet();
						for (String s : set) {
							httpBuilder.addQueryParameter(s, paramsMap.get(s));
						}
					}
					Request.Builder b = new Request.Builder();
					if (MapUtils.isNotEmpty(headersMap)) {
						Set<String> set = headersMap.keySet();
						for (String s : set) {
							b.addHeader(s, headersMap.get(s));
						}

					}
					LOGGER.info("buildRequest, body:"+body);
					Request req = b.url(httpBuilder.build()).put(body).build();
					return req;
		}
					
			
}
